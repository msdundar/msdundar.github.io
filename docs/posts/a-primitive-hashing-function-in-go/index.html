<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A Primitive Hashing Function in Go | Blog of Serhat M. Dündar | Ruby, Rails, Golang, PostgreSQL, AWS, Security</title><meta name=keywords content="security,golang,hashing"><meta name=description content="A primitive hashing function written in Go to demonstrate concepts such as an XOR machine."><meta name=author content="Serhat M. Dündar"><link rel=canonical href=https://www.serhatdundar.com/posts/a-primitive-hashing-function-in-go/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.serhatdundar.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.serhatdundar.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.serhatdundar.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.serhatdundar.com/apple-touch-icon.png><link rel=mask-icon href=https://www.serhatdundar.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-45TXZR4LGJ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-45TXZR4LGJ",{anonymize_ip:!1})}</script><meta property="og:title" content="A Primitive Hashing Function in Go"><meta property="og:description" content="A primitive hashing function written in Go to demonstrate concepts such as an XOR machine."><meta property="og:type" content="article"><meta property="og:url" content="https://www.serhatdundar.com/posts/a-primitive-hashing-function-in-go/"><meta property="og:image" content="https://www.serhatdundar.com/posts/a-primitive-hashing-function-in-go/assets/bords-de-riviere-1868-johan-barthold-jongkind.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-23T18:30:19+02:00"><meta property="article:modified_time" content="2022-01-23T18:30:19+02:00"><meta property="og:site_name" content="Blog of Serhat M. Dündar"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.serhatdundar.com/posts/a-primitive-hashing-function-in-go/assets/bords-de-riviere-1868-johan-barthold-jongkind.jpg"><meta name=twitter:title content="A Primitive Hashing Function in Go"><meta name=twitter:description content="A primitive hashing function written in Go to demonstrate concepts such as an XOR machine."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.serhatdundar.com/posts/"},{"@type":"ListItem","position":2,"name":"A Primitive Hashing Function in Go","item":"https://www.serhatdundar.com/posts/a-primitive-hashing-function-in-go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A Primitive Hashing Function in Go","name":"A Primitive Hashing Function in Go","description":"A primitive hashing function written in Go to demonstrate concepts such as an XOR machine.","keywords":["security","golang","hashing"],"articleBody":"Cryptographic hash functions are complex mathematical calculations. Therefore understanding them requires a considerable amount of time and patience. However, they all have things in common: an input, a cryptographic algorithm, and an output.\nRecently, I had a chance to study some popular cryptographic hash functions, such as MD5 and SHA-1, and tried to understand how they really work. Wikipedia pages I linked include a considerable amount of information already, and more can be found online, but what I want to do was understand similarities between them and write my own primitive hashing function in Go.\nSplitting an input into chunks, dividing chunks into fixed-sized bit blocks, adding bits, padding messages with 0 bit, shifting bits, running xor on bits, and so on are some common methods that can you come across in many hashing algorithms. I will not use all these practices in my “primitive” implementation, but I will cover enough to make a reader get started.\nFirst, let’s start by remembering the requirements for any hashing algorithm:\nInfeasible to produce a given digest (you can’t guess possible plaintext messages) Impossible to extract original message (hashing must be one-way) Slight changes in the original message should produce drastic changes in the digest Resulting digest is fixed-width (length) Should be fast, but also not too fast! Besides these strict requirements, we also want as few hash collision as possible. The thing is, collisions can’t be avoided in hashing, because it’s a byproduct of fixed width digests. They can only be made rare. To make them rarer, we can simply use big block sizes, and as a result, we end up with big checksums. I won’t be concerned too much about collisions or security here, as what I’m trying to write is just a primitive hashing function for educational purposes, and not something production-ready.\nHere is the full code: https://gist.github.com/msdundar/f88aee1a89d603b3d81f9087e3dc1012\nStep 1: Convert string to binary We will be using a binary representation to run an XOR machine later. Therefore, any input needs to be converted to binary first:\nh e l l o w o r l d 01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 // stringToBinary converts strings to binary func stringToBinary(s string) (binaryString string) { for _, c := range s { binaryString = fmt.Sprintf(\"%s%.8b\", binaryString, c) } return } Step 2: Split binary into bit-blocks and pad blocks with 0-bit Here I use blocks of 32bits for simplicity, but in actual implementation it’s 128bits:\nhell owor ld 01101000011001010110110001101100 01101111001000000111011101101111 01110010011011000000000000000000 For this example, I decided to use blocks of 128bits, but you can configure it depending on your needs. Keep in mind, a bigger block size will perform badly for short messages but will reduce the chances of collision for long messages. Think about these tradeoffs when modifying this value.\nHere, I’m splitting the binary string into blocks of 128bits, and I pad blocks with 0 bit if they are shorter than 128bits:\n// splitToBlocks takes a binary string and splits it into blocks func splitToBlocks(msg string) []string{ desiredBlockSize := 128 numberOfBits := len(msg) requiredSliceCap := int(math.Ceil( float64(numberOfBits)/float64(desiredBlockSize)), ) fourByteSlice := make([]string, requiredSliceCap) byteIndex := 0 for i := 0; i \u003c len(msg); i++ { if i != 0 \u0026\u0026 i % desiredBlockSize == 0 { byteIndex += 1 } fourByteSlice[byteIndex] = fourByteSlice[byteIndex] + string(msg[i]) } // Pad with 0s to ensure all blocks are the same size for ; len(fourByteSlice[byteIndex]) \u003c desiredBlockSize; { fourByteSlice[byteIndex] = fourByteSlice[byteIndex] + \"0\" } return fourByteSlice } Step 3: Create a simple XOR machine Running XOR on bits is a very common technique for many hashing algorithms. When using big block sizes, each XOR makes it much harder to reverse the hashing process. However, with short messages, there will be fewer blocks to use with XOR, and the process can be reversed if no additional hardening is implemented. However, we aren’t much concerned about collisions in this primitive example.\n// xorMachine runs longitudinal parity checks on given blocks func xorMachine(item1 string, item2 string) string{ var xorOutput string for i, _ := range item1 { if item1[i] == item2[i] { xorOutput += \"0\" } else { xorOutput += \"1\" } } return xorOutput } Step 4: Pass bit-blocks to XOR machine one-by-one In this step, all we need to do is pass bit-blocks to the XOR machine one by one:\nbinaryStringSlc := splitToBlocks( stringToBinary(\"Hello world! This is Serhat! This post is all about implementing a primitive hashing function in Go.\"), ) for i := 0; i \u003c len(binaryStringSlc); i++{ if !(i+1 == len(binaryStringSlc)) { comparisonStr := xorMachine(binaryStringSlc[i], binaryStringSlc[i+1]) binaryStringSlc[i+1] = comparisonStr } } fmt.Println(binaryStringSlc[len(binaryStringSlc)-1]) And voila! Here is our checksum in binary:\n01001111010111110010000001101001000001110110010101011010000111110001101101011101000010110000100001010110000000010000011100011000 Needless to say, you should never use this hashing function on production and you should never try to write your own encryption algorithm either. Existing hashing functions are 100x more complicated than this, and probably 1000x more secure. Therefore, you should only use battle-tested hashing algorithms such as SHA-3, bcrypt, and so on.\n","wordCount":"826","inLanguage":"en","image":"https://www.serhatdundar.com/posts/a-primitive-hashing-function-in-go/assets/bords-de-riviere-1868-johan-barthold-jongkind.jpg","datePublished":"2022-01-23T18:30:19+02:00","dateModified":"2022-01-23T18:30:19+02:00","author":{"@type":"Person","name":"Serhat M. Dündar"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.serhatdundar.com/posts/a-primitive-hashing-function-in-go/"},"publisher":{"@type":"Organization","name":"Blog of Serhat M. Dündar | Ruby, Rails, Golang, PostgreSQL, AWS, Security","logo":{"@type":"ImageObject","url":"https://www.serhatdundar.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.serhatdundar.com/ accesskey=h title="Home (Alt + H)"><img src=https://www.serhatdundar.com/apple-touch-icon.png alt=logo aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.serhatdundar.com/tags/ title=tags><span>tags</span></a></li><li><a href=https://www.serhatdundar.com/archives/ title=archives><span>archives</span></a></li><li><a href=https://www.serhatdundar.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://www.serhatdundar.com/art/ title=artwork><span>artwork</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.serhatdundar.com/>Home</a>&nbsp;»&nbsp;<a href=https://www.serhatdundar.com/posts/>Posts</a></div><h1 class=post-title>A Primitive Hashing Function in Go</h1><div class=post-description>A primitive hashing function written in Go to demonstrate concepts such as an XOR machine.</div><div class=post-meta><span title='2022-01-23 18:30:19 +0200 +0200'>January 23, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Serhat M. Dündar&nbsp;|&nbsp;<a href=https://github.com/msdundar/msdundar.github.io/tree/main/content/posts/a-primitive-hashing-function-in-go/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=https://www.serhatdundar.com/posts/a-primitive-hashing-function-in-go/assets/bords-de-riviere-1868-johan-barthold-jongkind.jpg alt="Bords de riviere (1868) - Johan Barthold Jongkind"></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#step-1-convert-string-to-binary aria-label="Step 1: Convert string to binary">Step 1: Convert string to binary</a></li><li><a href=#step-2-split-binary-into-bit-blocks-and-pad-blocks-with-0-bit aria-label="Step 2: Split binary into bit-blocks and pad blocks with 0-bit">Step 2: Split binary into bit-blocks and pad blocks with 0-bit</a></li><li><a href=#step-3-create-a-simple-xor-machine aria-label="Step 3: Create a simple XOR machine">Step 3: Create a simple XOR machine</a></li><li><a href=#step-4-pass-bit-blocks-to-xor-machine-one-by-one aria-label="Step 4: Pass bit-blocks to XOR machine one-by-one">Step 4: Pass bit-blocks to XOR machine one-by-one</a></li></ul></div></details></div><div class=post-content><p>Cryptographic hash functions are complex mathematical calculations. Therefore understanding them requires a considerable
amount of time and patience. However, they all have things in common: an input, a cryptographic algorithm, and an output.</p><p>Recently, I had a chance to study some popular cryptographic hash functions, such as
<a href=https://en.wikipedia.org/wiki/MD5>MD5</a> and <a href=https://en.wikipedia.org/wiki/SHA-1>SHA-1</a>, and tried to understand how
they really work. Wikipedia pages I linked include a considerable amount of information already, and more can be found
online, but what I want to do was understand similarities between them and write my own primitive hashing
function in Go.</p><p>Splitting an input into chunks, dividing chunks into fixed-sized bit blocks, adding bits, padding messages with 0 bit,
shifting bits, running xor on bits, and so on are some common methods that can you come across in many hashing
algorithms. I will not use all these practices in my &ldquo;primitive&rdquo; implementation, but I will cover enough to make a
reader get started.</p><p>First, let&rsquo;s start by remembering the requirements for any hashing algorithm:</p><ul><li>Infeasible to produce a given digest (you can&rsquo;t guess possible plaintext messages)</li><li>Impossible to extract original message (hashing must be one-way)</li><li>Slight changes in the original message should produce drastic changes in the digest</li><li>Resulting digest is fixed-width (length)</li><li>Should be fast, but also not too fast!</li></ul><p>Besides these strict requirements, we also want as few <a href=https://en.wikipedia.org/wiki/Hash_collision>hash collision</a> as
possible. The thing is, collisions can&rsquo;t be avoided in hashing, because it&rsquo;s a byproduct of <em>fixed width digests</em>. They
can only be made rare. To make them rarer, we can simply use big block sizes, and as a result, we end up with
big checksums. I won&rsquo;t be concerned too much about collisions or security here, as what I&rsquo;m trying to write is just a
primitive hashing function for educational purposes, and not something production-ready.</p><blockquote><p>Here is the full code: <a href=https://gist.github.com/msdundar/f88aee1a89d603b3d81f9087e3dc1012>https://gist.github.com/msdundar/f88aee1a89d603b3d81f9087e3dc1012</a></p></blockquote><h3 id=step-1-convert-string-to-binary>Step 1: Convert string to binary<a hidden class=anchor aria-hidden=true href=#step-1-convert-string-to-binary>#</a></h3><p>We will be using a binary representation to run an XOR machine later. Therefore, any input needs to be converted to
binary first:</p><pre tabindex=0><code>    h        e        l        l        o        w        o        r       l        d
01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// stringToBinary converts strings to binary
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>stringToBinary</span>(<span style=color:#a6e22e>s</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>binaryString</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>s</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>binaryString</span> = <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%s%.8b&#34;</span>, <span style=color:#a6e22e>binaryString</span>, <span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=step-2-split-binary-into-bit-blocks-and-pad-blocks-with-0-bit>Step 2: Split binary into bit-blocks and pad blocks with 0-bit<a hidden class=anchor aria-hidden=true href=#step-2-split-binary-into-bit-blocks-and-pad-blocks-with-0-bit>#</a></h3><p>Here I use blocks of 32bits for simplicity, but in actual implementation it&rsquo;s 128bits:</p><pre tabindex=0><code>              hell                             owor                             ld
01101000011001010110110001101100 01101111001000000111011101101111 01110010011011000000000000000000
</code></pre><p>For this example, I decided to use blocks of 128bits, but you can configure it depending on your needs. Keep in mind,
a bigger block size will perform badly for short messages but will reduce the chances of collision for long messages.
Think about these tradeoffs when modifying this value.</p><p>Here, I&rsquo;m splitting the binary string into blocks of 128bits, and I pad blocks with 0 bit if they are shorter than
128bits:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// splitToBlocks takes a binary string and splits it into blocks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>splitToBlocks</span>(<span style=color:#a6e22e>msg</span> <span style=color:#66d9ef>string</span>) []<span style=color:#66d9ef>string</span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>desiredBlockSize</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>128</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>numberOfBits</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>msg</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>requiredSliceCap</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Ceil</span>(
</span></span><span style=display:flex><span>    float64(<span style=color:#a6e22e>numberOfBits</span>)<span style=color:#f92672>/</span>float64(<span style=color:#a6e22e>desiredBlockSize</span>)),
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fourByteSlice</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>requiredSliceCap</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>byteIndex</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>msg</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>%</span> <span style=color:#a6e22e>desiredBlockSize</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>byteIndex</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fourByteSlice</span>[<span style=color:#a6e22e>byteIndex</span>] = <span style=color:#a6e22e>fourByteSlice</span>[<span style=color:#a6e22e>byteIndex</span>] <span style=color:#f92672>+</span> string(<span style=color:#a6e22e>msg</span>[<span style=color:#a6e22e>i</span>])
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Pad with 0s to ensure all blocks are the same size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> ; len(<span style=color:#a6e22e>fourByteSlice</span>[<span style=color:#a6e22e>byteIndex</span>]) &lt; <span style=color:#a6e22e>desiredBlockSize</span>; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fourByteSlice</span>[<span style=color:#a6e22e>byteIndex</span>] = <span style=color:#a6e22e>fourByteSlice</span>[<span style=color:#a6e22e>byteIndex</span>] <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;0&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fourByteSlice</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=step-3-create-a-simple-xor-machine>Step 3: Create a simple XOR machine<a hidden class=anchor aria-hidden=true href=#step-3-create-a-simple-xor-machine>#</a></h3><p>Running XOR on bits is a very common technique for many hashing algorithms. When using big block sizes, each XOR
makes it much harder to reverse the hashing process. However, with short messages, there will be fewer blocks to use
with XOR, and the process can be reversed if no additional hardening is implemented. However, we aren&rsquo;t much concerned
about collisions in this <em>primitive example</em>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// xorMachine runs longitudinal parity checks on given blocks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>xorMachine</span>(<span style=color:#a6e22e>item1</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>item2</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>xorOutput</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>item1</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>item1</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>item2</span>[<span style=color:#a6e22e>i</span>] {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>xorOutput</span> <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;0&#34;</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>xorOutput</span> <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;1&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>xorOutput</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=step-4-pass-bit-blocks-to-xor-machine-one-by-one>Step 4: Pass bit-blocks to XOR machine one-by-one<a hidden class=anchor aria-hidden=true href=#step-4-pass-bit-blocks-to-xor-machine-one-by-one>#</a></h3><p>In this step, all we need to do is pass bit-blocks to the XOR machine one by one:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>binaryStringSlc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>splitToBlocks</span>(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>stringToBinary</span>(<span style=color:#e6db74>&#34;Hello world! This is Serhat! This post is all about implementing a primitive hashing function in Go.&#34;</span>),
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>binaryStringSlc</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> !(<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> len(<span style=color:#a6e22e>binaryStringSlc</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>comparisonStr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>xorMachine</span>(<span style=color:#a6e22e>binaryStringSlc</span>[<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>binaryStringSlc</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>binaryStringSlc</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] = <span style=color:#a6e22e>comparisonStr</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>binaryStringSlc</span>[len(<span style=color:#a6e22e>binaryStringSlc</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>])
</span></span></code></pre></div><p>And voila! Here is our checksum in binary:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ae81ff>01001111010111110010000001101001000001110110010101011010000111110001101101011101000010110000100001010110000000010000011100011000</span>
</span></span></code></pre></div><p>Needless to say, you should never use this hashing function on production and you should never try to write your own
encryption algorithm either. Existing hashing functions are 100x more complicated than this, and probably 1000x more
secure. Therefore, you should only use battle-tested hashing algorithms such as SHA-3, bcrypt, and so on.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.serhatdundar.com/tags/security/>security</a></li><li><a href=https://www.serhatdundar.com/tags/golang/>golang</a></li><li><a href=https://www.serhatdundar.com/tags/hashing/>hashing</a></li></ul><nav class=paginav><a class=prev href=https://www.serhatdundar.com/posts/storing-passwords-in-a-database/><span class=title>« Prev</span><br><span>Storing Passwords in a Database: Hashing, Salts, and Peppers</span></a>
<a class=next href=https://www.serhatdundar.com/posts/ssl-tls-handshake-hybrid-encryption/><span class=title>Next »</span><br><span>SSL/TLS Handshake, Hybrid Encryption and Public Key Infrastructure (PKI)</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share A Primitive Hashing Function in Go on twitter" href="https://twitter.com/intent/tweet/?text=A%20Primitive%20Hashing%20Function%20in%20Go&url=https%3a%2f%2fwww.serhatdundar.com%2fposts%2fa-primitive-hashing-function-in-go%2f&hashtags=security%2cgolang%2chashing"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A Primitive Hashing Function in Go on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwww.serhatdundar.com%2fposts%2fa-primitive-hashing-function-in-go%2f&title=A%20Primitive%20Hashing%20Function%20in%20Go&summary=A%20Primitive%20Hashing%20Function%20in%20Go&source=https%3a%2f%2fwww.serhatdundar.com%2fposts%2fa-primitive-hashing-function-in-go%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A Primitive Hashing Function in Go on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.serhatdundar.com%2fposts%2fa-primitive-hashing-function-in-go%2f&title=A%20Primitive%20Hashing%20Function%20in%20Go"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A Primitive Hashing Function in Go on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.serhatdundar.com%2fposts%2fa-primitive-hashing-function-in-go%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A Primitive Hashing Function in Go on whatsapp" href="https://api.whatsapp.com/send?text=A%20Primitive%20Hashing%20Function%20in%20Go%20-%20https%3a%2f%2fwww.serhatdundar.com%2fposts%2fa-primitive-hashing-function-in-go%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A Primitive Hashing Function in Go on telegram" href="https://telegram.me/share/url?text=A%20Primitive%20Hashing%20Function%20in%20Go&url=https%3a%2f%2fwww.serhatdundar.com%2fposts%2fa-primitive-hashing-function-in-go%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.serhatdundar.com/>Blog of Serhat M. Dündar | Ruby, Rails, Golang, PostgreSQL, AWS, Security</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>