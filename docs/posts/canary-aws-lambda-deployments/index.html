<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Canary AWS Lambda Deployments | Blog of Serhat M. Dündar | Ruby, Rails, Golang, PostgreSQL, AWS, Security</title><meta name=keywords content="aws,lambda,golang"><meta name=description content="Gradual/Canary deployments with AWS Lambda explained."><meta name=author content="Serhat M. Dündar"><link rel=canonical href=https://www.serhatdundar.com/posts/canary-aws-lambda-deployments/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.serhatdundar.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.serhatdundar.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.serhatdundar.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.serhatdundar.com/apple-touch-icon.png><link rel=mask-icon href=https://www.serhatdundar.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-45TXZR4LGJ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-45TXZR4LGJ",{anonymize_ip:!1})}</script><meta property="og:title" content="Canary AWS Lambda Deployments"><meta property="og:description" content="Gradual/Canary deployments with AWS Lambda explained."><meta property="og:type" content="article"><meta property="og:url" content="https://www.serhatdundar.com/posts/canary-aws-lambda-deployments/"><meta property="og:image" content="https://www.serhatdundar.com/posts/canary-aws-lambda-deployments/assets/la-campagne-nivernaise-1873-johan-barthold-jongkind.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-14T22:50:45+02:00"><meta property="article:modified_time" content="2021-06-14T22:50:45+02:00"><meta property="og:site_name" content="Blog of Serhat M. Dündar"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.serhatdundar.com/posts/canary-aws-lambda-deployments/assets/la-campagne-nivernaise-1873-johan-barthold-jongkind.jpg"><meta name=twitter:title content="Canary AWS Lambda Deployments"><meta name=twitter:description content="Gradual/Canary deployments with AWS Lambda explained."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.serhatdundar.com/posts/"},{"@type":"ListItem","position":2,"name":"Canary AWS Lambda Deployments","item":"https://www.serhatdundar.com/posts/canary-aws-lambda-deployments/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Canary AWS Lambda Deployments","name":"Canary AWS Lambda Deployments","description":"Gradual/Canary deployments with AWS Lambda explained.","keywords":["aws","lambda","golang"],"articleBody":"Lambdas aren’t easy. This isn’t just a provocative start, but instead my overall experience planning, creating, and deploying them.\nLet’s be honest, making something up and running requires plenty of AWS knowledge. One might get lost easily even inside IAM alone.\nIAM groups, IAM users, IAM roles, IAM group policy attachments, IAM policy documents, IAM role policies - and how they connect is confusing enough considering what Lambda promises, simplicity. And this is just IAM.\nNowadays no infrastructure is simple. If you’re old enough to remember days when developers used to drag and drop files in an FTP agent to deploy something, things have changed a long time ago.\nThe rationale behind the change is not tools and it’s not Lambda to blame, it’s the scale. Even the simplest solutions, such as Lambda and S3, have designed to scale, and when you start working on things that can scale, they get complicated quickly.\nThink about the most basic Lambda + API Gateway + DynamoDB setup you can imagine. You will still need to learn a lot about AWS. Most likely you’re going to need an average understanding of six different services, at minimum. Lambda, API Gateway, S3, IAM, DynamoDB, CloudWatch and so on.\nThe number of development practices we follow has also evolved rapidly with the growing scale. Nowadays almost any software project has at least two environments (production, staging etc.), projects often deployed on multiple geographical locations, continuous integration and continuous deployment are everyday tools and deployment choices are rich, starting from manual deployments to semi-automated and fully-automated. Logging, monitoring and incident management are essential stages that need to be considered for each service. If you think about all the pieces one needs to combine to get a simple setup up and running and to reflect all these pieces on Terraform, or in any other IAC tool, the complexity can’t be underestimated.\nUse Case I started to investigate available Lambda deployment strategies while working on a hobby project. I’ve been using Lambdas for more than two years, but deployment internals has always been a mystery to me, as I was lucky to join a company with rich internal tooling is already available. However, of course, I knew about my options, such as SAM, Serverless Framework, Terraform and AWS SDKs.\nAt Babbel, the deployment of a Lambda is hassle-free, thanks to the internal tooling available. One can easily set up continuous deployment or choose to follow a semi-automated deployment strategy within a couple of hours with tools already available for this purpose.\nHowever, without tools to deal with deployment, it’s like Wild West out there. In this article, I will summarize some common deployment practices that I came across during my research. But first of all, here is the infrastructure setup I have:\nGithub repositories managed by Terraform An AWS account fully managed by Terraform Two identical (resource-wise) environments for each AWS services, production and staging. IAM setup is near perfect, no services can do more than they supposed to. Service accesses, roles, policies and permissions are finely tuned. Log groups are organized clearly. Alarms and budgets set up for each service. A simple DynamoDB database to store names, such as “John Doe” An S3 bucket with versioning enabled to store lambda packages as .zip files. An API Gateway with a simple GET endpoint that is used as an event source for the lambda. Github Actions (CI) is enabled and it takes care of packing lambda functions and uploading them to the S3 bucket. The lambda function has an extensive test suite and tested both locally and on CI. Here is how my demo system works:\nAn HTTP GET request together with a query string parameter is sent to the API Gateway, i.e.: https://foo.com/names?name=John API Gateway triggers the lambda function. Lambda function queries the name in DynamoDB, and if a matching record has found in the database it returns 200 and a simple JSON in the body, otherwise, it returns 404 and an empty body. The Next Step Briefly, I have a setup that I can test on AWS or locally. My Github Actions setup can pack the lambda and upload it to the S3 bucket. Now it’s time to decide on continuous deployment!\nThese are my acceptance criteria for Lambda deployments:\nCI should take care of lambda aliases and versioning. An IAM user dedicated to CI should only have minimum possible permissions, and should only access resources it actually manages. Changes reflected in main should be deployed to production lambda. Changes reflected in develop should be deployed to staging lambda. Deployments should be gradual on production. Deployments should be all at once on staging. CI should auto-rollback the deployment if a failure happens during the gradual deployment. CI should implement a health-check mechanism to see if the gradual deployment is successful. CI should take care of full roll-out when gradual deployment steps are successful. All CI actions should be runnable on local development environment without hassle. With these criteria in mind, I started researching my options and best-practices out there.\nDeployments with Terraform I’ve listed 3 different approaches here. However, deployments with Terraform violates some criteria I’ve listed above. First of all, resources should be initialized and configured with Terraform, but Terraform shouldn’t take care of internal changes of them, according to the ideal infrastructure in my mind. For example, Terraform should bring a lambda to life, configure its resources such as memory and timeout, but shouldn’t care about the code changes of a lambda.\nIt makes sense, right? If not, think about S3. Terraform creates buckets, defined policies and lifecycles for them, but doesn’t care about what you put into those buckets. With a similar point of view, I didn’t prefer Terraform deployments for the following reasons:\nIt just doesn’t feel right. Running a full terraform apply on CI requires an IAM user with extensive permissions. When multiple developers modify resources, keeping terraform tfstate in sync is a pain. However, I will still list approaches I came across while exploring this option:\nApproach 1: Keep a .version file in your github repository This option is about keeping a .version file in the code repository located on Github to track changes on the code. Deployments are going to be possible after running terraform apply either locally or on CI.\nInitialize the file with Terraform:\nresource \"github_repository_file\" \"name_searcher_lambda_version\" { repository = github_repository.name_searcher_lambda.name branch = \"main\" file = \".version\" content = \"v0.0.1\" commit_message = \"Initialize the version file\" commit_author = \"Someone\" commit_email = \"something@gmail.com\" } Add source_code_hash key to your lambda:\nresource \"aws_lambda_function\" \"name_searcher\" { function_name = \"name-searcher\" handler = \"main\" runtime = \"go1.x\" memory_size = 128 timeout = 5 s3_bucket = aws_s3_bucket.lambda_sources[each.key].bucket s3_key = \"${github_repository.name_searcher_lambda.name}/index.zip\" source_code_hash = github_repository_file.name_searcher_lambda_version.commit_sha } In this scenario, the lambda function is going to use the commit_sha of the .version file as source_code_hash. .version file needs to be updated whenever you would like to publish the lambda again. After the commit_sha has modified, you also need to run terraform apply to re-deploy the lambda from the S3 bucket.\nI didn’t like this approach at all.\nApproach 2: Store lambda packages in version-aware subfolders on S3 This approach is the one used in the official Terraform documentation for lambdas.\nIn this approach, you need to upload your lambda packages under versioned subfolders as follows:\ns3://lambda-sources/name-searcher/1.1.0/index.zip Then add the following to the variables.tf to get version number as a variable:\nvariable \"lambda_version\" {} Finally, add the lambda_version to the s3_key:\ns3_key = \"v${var.lambda_version}/example.zip\" Run terraform_apply with the lambda_version variable to deploy changes:\nterraform apply -var lambda_version=\"1.0.1\" For rolling back the deployment with an older version, follow the same logic:\nterraform apply -var lambda_version=\"0.0.5\" In this approach, you still need to take care of version numbers either locally or in your CI. Again, this approach requires too much manual intervention and violates my acceptance criteria.\nApproach 3: Upload .zip SHA as plaintext to S3 I’ve seen this approach in John Roach’s blog. It’s similar to the first two approaches but this one takes actual source code changes into consideration by getting the SHA of the whole deployment package for change tracking purposes.\nIn this approach, you need to upload a plaintext file including the SHA of the deployment package to the S3 bucket together with your .zip file. In the end, there will be two files in your S3 bucket for a lambda:\nlambda_package.zip # lambda deployment package lambda_package.zip.sha256 # plaintext file including SHA of the lambda_package.zip Then use this SHA as source_code_hash in your lambda:\ndata \"aws_s3_bucket_object\" \"name_searcher_hash\" { bucket = \"lambda-sources\" key = \"path/name_searcher_payload.zip.base64sha256\" } resource \"aws_lambda_function\" \"name_searcher\" { source_code_hash = data.aws_s3_bucket_object.name_searcher_hash.body s3_bucket = \"lambda-sources\" s3_key = \"path/lambda_function_payload.zip\" } The author of this approach prefers to ignore source_code_hash changes in lifecycle rules (which makes sense) and re-deploys the lambda function as follows:\naws lambda update-function-code --function-name name_searcher \\ --s3-bucket lambda-sources \\ --s3-key path/lambda_function_payload.zip This approach can also be combined with the first two approaches. You can treat commit SHAs similar to versions, and vice versa, it all depends on your choices. I only provided a modified brief version of this approach, so visit the original post for more details.\nDeployments with SAM SAM specification is great to make things up and running quickly, especially if your infrastructure isn’t complex. For the use case I mentioned earlier SAM could be an option, however, there are things I don’t like about SAM:\nIt just doesn’t feel right when used together with Terraform. SAM doesn’t support some AWS services such as IAM Role, IAM Policy, KMS etc. This forces infrastructure to split between Terraform and SAM, and I want a single source of truth, Terraform. SAM makes more sense and provides convenience especially when used together with other services such as API Gateway, however, I prefer to keep them in Terraform. It’s a little bit magical! I don’t feel comfortable SAM creating IAM roles and permission automatically for me. Programmatic access and structuring in SAM templates are ugly. Plenty of IAM permissions needs to be granted to run sam deploy on CI that again I prefer to avoid. Because of the listed reasons, I decided not to evaluate SAM as an option.\nDeployments with Serverless Serverless and SAM are somehow similar, both are CloudFormation abstractions, and both generate CloudFormation templates. For the use case I mentioned, Serverless again didn’t feel right for the same reasons I’ve listed for SAM.\nDeployments with AWS SDK AWS SDK is at the core of AWS services. The amount of functionality they provide enables developers to build their custom solutions on top of what is already available. Therefire, I’ve adopted AWS SDK and built my own deployment workflow satisfying all acceptance criteria I’ve defined. Here are the details:\nAn IAM user for CI usage with policies (aws_iam_policy_document) including minimum possible permissions:\n# Only for the bucket that CI can upload \"s3:Get*\" \"s3:List*\" \"s3:PutObject\" \"s3:PutObjectAcl\" # Only for the lambda that CI can deploy \"lambda:GetFunction\" \"lambda:GetFunctionConfiguration\" \"lambda:InvokeFunction\" \"lambda:UpdateFunctionCode\" \"lambda:PublishVersion\" \"lambda:UpdateAlias\" Credentials of this IAM user are being added to the Github Repository of lambda as secrets by Terraform. The IAM user of CI can only upload files to the S3 lambda_sources S3 bucket, and can’t access others. Similarly, it can only deploy the related lambda, not others.\nThere is an alias that is going to be exposed for client usage, named live. The ARN of the alias I’ve created is the one to be triggered from API Gateway:\nresource \"aws_lambda_function\" \"name_searcher\" { for_each = var.environments function_name = \"name-searcher-${each.key}\" description = \"Queries the harmful-domains DynamoDB table\" handler = \"main\" runtime = \"go1.x\" memory_size = 128 timeout = 5 s3_bucket = aws_s3_bucket.lambda_sources[each.key].bucket s3_key = \"${github_repository.name_searcher_lambda.name}/v1.0.0/index.zip\" role = aws_iam_role.lambda_name_searcher.arn } resource \"aws_lambda_alias\" \"name_searcher\" { for_each = var.environments name = \"live\" description = \"Live version of the lambda. Gradual traffic shifting in place.\" function_name = aws_lambda_function.name_searcher[each.key].arn function_version = \"$LATEST\" lifecycle { ignore_changes = [function_version] } } ignore_changes part here is important because I want CI to manage releases.\nThe rest is pretty standard. An S3 bucket, some Terraform config for managing the Github repository and so on.\nAfter creating the initial infrastructure I’ve decided to create a Go module to take care of canary Lambda deployments. Therefore, I’ve created a module around AWS SDK and integrated into the CI setup of all my personal lambda projects.\nHere are you can have a look:\nhttps://github.com/msdundar/kanarya\nReferences https://learn.hashicorp.com/tutorials/terraform/lambda-api-gateway https://johnroach.io/2020/09/04/deploying-lambda-functions-with-terraform-just-dont/ https://medium.com/galvanize/aws-lambda-deployment-with-terraform-24d36cc86533 https://docs.aws.amazon.com/sdk-for-go/api/service/lambda/ ","wordCount":"2059","inLanguage":"en","image":"https://www.serhatdundar.com/posts/canary-aws-lambda-deployments/assets/la-campagne-nivernaise-1873-johan-barthold-jongkind.jpg","datePublished":"2021-06-14T22:50:45+02:00","dateModified":"2021-06-14T22:50:45+02:00","author":{"@type":"Person","name":"Serhat M. Dündar"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.serhatdundar.com/posts/canary-aws-lambda-deployments/"},"publisher":{"@type":"Organization","name":"Blog of Serhat M. Dündar | Ruby, Rails, Golang, PostgreSQL, AWS, Security","logo":{"@type":"ImageObject","url":"https://www.serhatdundar.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.serhatdundar.com/ accesskey=h title="Home (Alt + H)"><img src=https://www.serhatdundar.com/apple-touch-icon.png alt=logo aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.serhatdundar.com/tags/ title=tags><span>tags</span></a></li><li><a href=https://www.serhatdundar.com/archives/ title=archives><span>archives</span></a></li><li><a href=https://www.serhatdundar.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://www.serhatdundar.com/art/ title=artwork><span>artwork</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.serhatdundar.com/>Home</a>&nbsp;»&nbsp;<a href=https://www.serhatdundar.com/posts/>Posts</a></div><h1 class=post-title>Canary AWS Lambda Deployments</h1><div class=post-description>Gradual/Canary deployments with AWS Lambda explained.</div><div class=post-meta><span title='2021-06-14 22:50:45 +0200 CEST'>June 14, 2021</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Serhat M. Dündar&nbsp;|&nbsp;<a href=https://github.com/msdundar/msdundar.github.io/tree/main/content/posts/canary-aws-lambda-deployments/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=https://www.serhatdundar.com/posts/canary-aws-lambda-deployments/assets/la-campagne-nivernaise-1873-johan-barthold-jongkind.jpg alt="La Campagne Nivernaise (1873) - Johan Barthold Jongkind"></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#use-case aria-label="Use Case">Use Case</a></li><li><a href=#the-next-step aria-label="The Next Step">The Next Step</a></li><li><a href=#deployments-with-terraform aria-label="Deployments with Terraform">Deployments with Terraform</a><ul><li><a href=#approach-1-keep-a-version-file-in-your-github-repository aria-label="Approach 1: Keep a .version file in your github repository">Approach 1: Keep a .version file in your github repository</a></li><li><a href=#approach-2-store-lambda-packages-in-version-aware-subfolders-on-s3 aria-label="Approach 2: Store lambda packages in version-aware subfolders on S3">Approach 2: Store lambda packages in version-aware subfolders on S3</a></li><li><a href=#approach-3-upload-zip-sha-as-plaintext-to-s3 aria-label="Approach 3: Upload .zip SHA as plaintext to S3">Approach 3: Upload .zip SHA as plaintext to S3</a></li></ul></li><li><a href=#deployments-with-sam aria-label="Deployments with SAM">Deployments with SAM</a></li><li><a href=#deployments-with-serverless aria-label="Deployments with Serverless">Deployments with Serverless</a></li><li><a href=#deployments-with-aws-sdk aria-label="Deployments with AWS SDK">Deployments with AWS SDK</a></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><p>Lambdas aren&rsquo;t easy. This isn&rsquo;t just a provocative start, but instead my overall
experience planning, creating, and deploying them.</p><p>Let&rsquo;s be honest, making something up and running requires plenty of AWS
knowledge. One might get lost easily even inside IAM alone.</p><p>IAM groups, IAM users, IAM roles, IAM group policy attachments, IAM policy
documents, IAM role policies - and how they connect is confusing enough
considering what Lambda promises, simplicity. And this is just IAM.</p><p>Nowadays no infrastructure is simple. If you&rsquo;re old enough to remember days
when developers used to drag and drop files in an FTP agent to deploy something,
things have changed a long time ago.</p><p>The rationale behind the change is not tools and it&rsquo;s not Lambda to blame, it&rsquo;s
the scale. Even the simplest solutions, such as Lambda and S3, have designed to
scale, and when you start working on things that can scale, they get complicated
quickly.</p><p>Think about the most basic Lambda + API Gateway + DynamoDB setup you can
imagine. You will still need to learn a lot about AWS. Most likely you&rsquo;re going
to need an average understanding of six different services, at minimum. Lambda,
API Gateway, S3, IAM, DynamoDB, CloudWatch and so on.</p><p>The number of development practices we follow has also evolved rapidly with
the growing scale. Nowadays almost any software project has at least two
environments (production, staging etc.), projects often deployed on multiple
geographical locations, continuous integration and continuous deployment are
everyday tools and deployment choices are rich, starting from manual
deployments to semi-automated and fully-automated. Logging, monitoring and
incident management are essential stages that need to be considered for each
service. If you think about all the pieces one needs to combine to get a simple
setup up and running and to reflect all these pieces on Terraform, or in any
other IAC tool, the complexity can&rsquo;t be underestimated.</p><h2 id=use-case>Use Case<a hidden class=anchor aria-hidden=true href=#use-case>#</a></h2><p>I started to investigate available Lambda deployment strategies while working
on a hobby project. I&rsquo;ve been using Lambdas for more than two years, but
deployment internals has always been a mystery to me, as I was lucky to join a
company with rich internal tooling is already available. However, of course,
I knew about my options, such as <a href=https://aws.amazon.com/serverless/sam/>SAM</a>,
<a href=https://www.serverless.com/>Serverless Framework</a>,
<a href=https://www.terraform.io/>Terraform</a> and
<a href=https://aws.amazon.com/getting-started/tools-sdks/>AWS SDKs</a>.</p><p>At Babbel, the deployment of a Lambda is hassle-free, thanks to the internal
tooling available. One can easily set up continuous deployment or choose
to follow a semi-automated deployment strategy within a couple of hours with
tools already available for this purpose.</p><p>However, without tools to deal with deployment, it&rsquo;s like Wild West out there.
In this article, I will summarize some common deployment practices that I came
across during my research. But first of all, here is the infrastructure setup
I have:</p><ul><li>Github repositories managed by Terraform</li><li>An AWS account fully managed by Terraform</li><li>Two identical (resource-wise) environments for each AWS services, <code>production</code>
and <code>staging</code>.</li><li>IAM setup is near perfect, no services can do more than they supposed to.
Service accesses, roles, policies and permissions are finely tuned.</li><li>Log groups are organized clearly. Alarms and budgets set up for each service.</li><li>A simple DynamoDB database to store names, such as &ldquo;John Doe&rdquo;</li><li>An S3 bucket with versioning enabled to store lambda packages as .zip files.</li><li>An API Gateway with a simple GET endpoint that is used as an event source for
the lambda.</li><li>Github Actions (CI) is enabled and it takes care of packing lambda functions
and uploading them to the S3 bucket.</li><li>The lambda function has an extensive test suite and tested both locally and
on CI.</li></ul><p>Here is how my demo system works:</p><ul><li>An HTTP GET request together with a query string parameter is sent to the API
Gateway, i.e.: <a href="https://foo.com/names?name=John">https://foo.com/names?name=John</a></li><li>API Gateway triggers the lambda function. Lambda function queries the name
in DynamoDB, and if a matching record has found in the database it returns
<code>200</code> and a simple JSON in the body, otherwise, it returns <code>404</code> and an empty
body.</li></ul><h2 id=the-next-step>The Next Step<a hidden class=anchor aria-hidden=true href=#the-next-step>#</a></h2><p>Briefly, I have a setup that I can test on AWS or locally. My Github Actions
setup can pack the lambda and upload it to the S3 bucket. Now it&rsquo;s time to
decide on continuous deployment!</p><p>These are my acceptance criteria for Lambda deployments:</p><ul><li>CI should take care of lambda aliases and versioning.</li><li>An IAM user dedicated to CI should only have minimum possible permissions, and
should only access resources it actually manages.</li><li>Changes reflected in <code>main</code> should be deployed to <code>production</code> lambda.</li><li>Changes reflected in <code>develop</code> should be deployed to <code>staging</code> lambda.</li><li>Deployments should be <em>gradual</em> on <code>production</code>.</li><li>Deployments should be <em>all at once</em> on <code>staging</code>.</li><li>CI should auto-rollback the deployment if a failure happens during the gradual
deployment.</li><li>CI should implement a health-check mechanism to see if the gradual deployment
is successful.</li><li>CI should take care of full roll-out when gradual deployment steps are
successful.</li><li>All CI actions should be runnable on local development environment without
hassle.</li></ul><p>With these criteria in mind, I started researching my options and best-practices
out there.</p><h2 id=deployments-with-terraform>Deployments with Terraform<a hidden class=anchor aria-hidden=true href=#deployments-with-terraform>#</a></h2><p>I&rsquo;ve listed 3 different approaches here. However, deployments with Terraform
violates some criteria I&rsquo;ve listed above. First of all, resources should be
initialized and configured with Terraform, but Terraform shouldn&rsquo;t take care
of internal changes of them, according to the ideal infrastructure in my mind.
For example, Terraform should bring a lambda to life, configure its resources
such as memory and timeout, but shouldn&rsquo;t care about the code changes of a
lambda.</p><p>It makes sense, right? If not, think about S3. Terraform creates buckets,
defined policies and lifecycles for them, but doesn&rsquo;t care about what you put
into those buckets. With a similar point of view, I didn&rsquo;t prefer Terraform
deployments for the following reasons:</p><ul><li>It just doesn&rsquo;t feel right.</li><li>Running a full <code>terraform apply</code> on CI requires an IAM user with extensive
permissions.</li><li>When multiple developers modify resources, keeping terraform <code>tfstate</code> in sync
is a pain.</li></ul><p>However, I will still list approaches I came across while exploring this option:</p><h3 id=approach-1-keep-a-version-file-in-your-github-repository>Approach 1: Keep a .version file in your github repository<a hidden class=anchor aria-hidden=true href=#approach-1-keep-a-version-file-in-your-github-repository>#</a></h3><p>This option is about keeping a <code>.version</code> file in the code repository located on
Github to track changes on the code. Deployments are going to be possible after
running <code>terraform apply</code> either locally or on CI.</p><p>Initialize the file with Terraform:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;github_repository_file&#34; &#34;name_searcher_lambda_version&#34;</span> {
</span></span><span style=display:flex><span>  repository          <span style=color:#f92672>=</span> <span style=color:#66d9ef>github_repository</span>.<span style=color:#66d9ef>name_searcher_lambda</span>.<span style=color:#66d9ef>name</span>
</span></span><span style=display:flex><span>  branch              <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;main&#34;</span>
</span></span><span style=display:flex><span>  file                <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;.version&#34;</span>
</span></span><span style=display:flex><span>  content             <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;v0.0.1&#34;</span>
</span></span><span style=display:flex><span>  commit_message      <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Initialize the version file&#34;</span>
</span></span><span style=display:flex><span>  commit_author       <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Someone&#34;</span>
</span></span><span style=display:flex><span>  commit_email        <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;something@gmail.com&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Add <code>source_code_hash</code> key to your lambda:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;aws_lambda_function&#34; &#34;name_searcher&#34;</span> {
</span></span><span style=display:flex><span>  function_name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;name-searcher&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  handler     <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;main&#34;</span>
</span></span><span style=display:flex><span>  runtime     <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;go1.x&#34;</span>
</span></span><span style=display:flex><span>  memory_size <span style=color:#f92672>=</span> <span style=color:#ae81ff>128</span>
</span></span><span style=display:flex><span>  timeout     <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  s3_bucket <span style=color:#f92672>=</span> <span style=color:#66d9ef>aws_s3_bucket</span>.<span style=color:#66d9ef>lambda_sources</span>[<span style=color:#66d9ef>each</span>.<span style=color:#66d9ef>key</span>].<span style=color:#66d9ef>bucket</span>
</span></span><span style=display:flex><span>  s3_key    <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;${github_repository.name_searcher_lambda.name}/index.zip&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  source_code_hash <span style=color:#f92672>=</span> <span style=color:#66d9ef>github_repository_file</span>.<span style=color:#66d9ef>name_searcher_lambda_version</span>.<span style=color:#66d9ef>commit_sha</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this scenario, the lambda function is going to use the <code>commit_sha</code> of the
<code>.version</code> file as <code>source_code_hash</code>. <code>.version</code> file needs to be updated
whenever you would like to publish the lambda again. After the <code>commit_sha</code> has
modified, you also need to run <code>terraform apply</code> to re-deploy the lambda from
the S3 bucket.</p><p>I didn&rsquo;t like this approach at all.</p><h3 id=approach-2-store-lambda-packages-in-version-aware-subfolders-on-s3>Approach 2: Store lambda packages in version-aware subfolders on S3<a hidden class=anchor aria-hidden=true href=#approach-2-store-lambda-packages-in-version-aware-subfolders-on-s3>#</a></h3><p>This approach is the one used in the official
<a href=https://learn.hashicorp.com/tutorials/terraform/lambda-api-gateway>Terraform documentation</a>
for lambdas.</p><p>In this approach, you need to upload your lambda packages under versioned
subfolders as follows:</p><pre tabindex=0><code>s3://lambda-sources/name-searcher/1.1.0/index.zip
</code></pre><p>Then add the following to the <code>variables.tf</code> to get version number as a
variable:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>variable</span> <span style=color:#e6db74>&#34;lambda_version&#34;</span> {}
</span></span></code></pre></div><p>Finally, add the <code>lambda_version</code> to the <code>s3_key</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span>s3_key <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;v${var.lambda_version}/example.zip&#34;</span>
</span></span></code></pre></div><p>Run <code>terraform_apply</code> with the <code>lambda_version</code> variable to deploy changes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>terraform apply -var lambda_version<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;1.0.1&#34;</span>
</span></span></code></pre></div><p>For rolling back the deployment with an older version, follow the same logic:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>terraform apply -var lambda_version<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;0.0.5&#34;</span>
</span></span></code></pre></div><p>In this approach, you still need to take care of version numbers either locally
or in your CI. Again, this approach requires too much manual intervention and
violates my acceptance criteria.</p><h3 id=approach-3-upload-zip-sha-as-plaintext-to-s3>Approach 3: Upload .zip SHA as plaintext to S3<a hidden class=anchor aria-hidden=true href=#approach-3-upload-zip-sha-as-plaintext-to-s3>#</a></h3><p>I&rsquo;ve seen this approach in <a href=https://johnroach.io/2020/09/04/deploying-lambda-functions-with-terraform-just-dont/>John Roach&rsquo;s blog</a>.
It&rsquo;s similar to the first two approaches but this one takes actual source code
changes into consideration by getting the SHA of the whole deployment package for
change tracking purposes.</p><p>In this approach, you need to upload a plaintext file including the SHA of the
deployment package to the S3 bucket together with your .zip file. In the end,
there will be two files in your S3 bucket for a lambda:</p><pre tabindex=0><code>lambda_package.zip # lambda deployment package
lambda_package.zip.sha256 # plaintext file including SHA of the lambda_package.zip
</code></pre><p>Then use this SHA as <code>source_code_hash</code> in your lambda:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#e6db74>&#34;aws_s3_bucket_object&#34; &#34;name_searcher_hash&#34;</span> {
</span></span><span style=display:flex><span>  bucket <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;lambda-sources&#34;</span>
</span></span><span style=display:flex><span>  key    <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;path/name_searcher_payload.zip.base64sha256&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;aws_lambda_function&#34; &#34;name_searcher&#34;</span> {
</span></span><span style=display:flex><span>  source_code_hash <span style=color:#f92672>=</span> <span style=color:#66d9ef>data</span>.<span style=color:#66d9ef>aws_s3_bucket_object</span>.<span style=color:#66d9ef>name_searcher_hash</span>.<span style=color:#66d9ef>body</span>
</span></span><span style=display:flex><span>  s3_bucket        <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;lambda-sources&#34;</span>
</span></span><span style=display:flex><span>  s3_key           <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;path/lambda_function_payload.zip&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The author of this approach prefers to ignore <code>source_code_hash</code> changes in
lifecycle rules (which makes sense) and re-deploys the lambda function as
follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>aws lambda update-function-code --function-name name_searcher <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>                                --s3-bucket lambda-sources <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>                                --s3-key path/lambda_function_payload.zip
</span></span></code></pre></div><p>This approach can also be combined with the first two approaches. You can treat
commit SHAs similar to versions, and vice versa, it all depends on your choices.
I only provided a modified brief version of this approach, so visit the original
post for more details.</p><h2 id=deployments-with-sam>Deployments with SAM<a hidden class=anchor aria-hidden=true href=#deployments-with-sam>#</a></h2><p>SAM specification is great to make things up and running quickly, especially if
your infrastructure isn&rsquo;t complex. For the use case I mentioned earlier SAM
could be an option, however, there are things I don&rsquo;t like about SAM:</p><ul><li>It just doesn&rsquo;t feel right when used together with Terraform.</li><li>SAM doesn&rsquo;t support some AWS services such as IAM Role, IAM Policy, KMS etc.
This forces infrastructure to split between Terraform and SAM, and I want a
single source of truth, Terraform.</li><li>SAM makes more sense and provides convenience especially when used together
with other services such as API Gateway, however, I prefer to keep them in
Terraform.</li><li>It&rsquo;s a little bit magical! I don&rsquo;t feel comfortable SAM creating IAM roles
and permission automatically for me.</li><li>Programmatic access and structuring in SAM templates are ugly.</li><li>Plenty of IAM permissions needs to be granted to run <code>sam deploy</code> on CI that
again I prefer to avoid.</li></ul><p>Because of the listed reasons, I decided not to evaluate SAM as an option.</p><h2 id=deployments-with-serverless>Deployments with Serverless<a hidden class=anchor aria-hidden=true href=#deployments-with-serverless>#</a></h2><p>Serverless and SAM are somehow similar, both are CloudFormation abstractions,
and both generate CloudFormation templates. For the use case I mentioned,
Serverless again didn&rsquo;t feel right for the same reasons I&rsquo;ve listed for SAM.</p><h2 id=deployments-with-aws-sdk>Deployments with AWS SDK<a hidden class=anchor aria-hidden=true href=#deployments-with-aws-sdk>#</a></h2><p>AWS SDK is at the core of AWS services. The amount of functionality they provide
enables developers to build their custom solutions on top of what is already
available. Therefire, I&rsquo;ve adopted AWS SDK and built my own deployment workflow
satisfying all acceptance criteria I&rsquo;ve defined. Here are the details:</p><p>An IAM user for CI usage with policies (<code>aws_iam_policy_document</code>) including
minimum possible permissions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tf data-lang=tf><span style=display:flex><span><span style=color:#75715e># Only for the bucket that CI can upload
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#e6db74>&#34;s3:Get*&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;s3:List*&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;s3:PutObject&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;s3:PutObjectAcl&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e># Only for the lambda that CI can deploy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#e6db74>&#34;lambda:GetFunction&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;lambda:GetFunctionConfiguration&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;lambda:InvokeFunction&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;lambda:UpdateFunctionCode&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;lambda:PublishVersion&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;lambda:UpdateAlias&#34;</span>
</span></span></code></pre></div><p>Credentials of this IAM user are being added to the Github Repository of lambda
as <code>secrets</code> by Terraform. The IAM user of CI can only upload files to the S3
<code>lambda_sources</code> S3 bucket, and can&rsquo;t access others. Similarly, it can only
deploy the related lambda, not others.</p><p>There is an alias that is going to be exposed for client usage, named <code>live</code>.
The ARN of the alias I&rsquo;ve created is the one to be triggered from API Gateway:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tf data-lang=tf><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;aws_lambda_function&#34;</span> <span style=color:#e6db74>&#34;name_searcher&#34;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>for_each</span> = var.<span style=color:#a6e22e>environments</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>function_name</span> = <span style=color:#e6db74>&#34;name-searcher-</span><span style=color:#e6db74>${</span>each.<span style=color:#a6e22e>key</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>description</span>   = <span style=color:#e6db74>&#34;Queries the harmful-domains DynamoDB table&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>handler</span>     = <span style=color:#e6db74>&#34;main&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>runtime</span>     = <span style=color:#e6db74>&#34;go1.x&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>memory_size</span> = <span style=color:#ae81ff>128</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>timeout</span>     = <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>s3_bucket</span> = <span style=color:#a6e22e>aws_s3_bucket</span>.<span style=color:#a6e22e>lambda_sources</span>[each.<span style=color:#a6e22e>key</span>].<span style=color:#a6e22e>bucket</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>s3_key</span>    = <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>github_repository</span>.<span style=color:#a6e22e>name_searcher_lambda</span>.<span style=color:#a6e22e>name</span><span style=color:#e6db74>}</span><span style=color:#e6db74>/v1.0.0/index.zip&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>role</span> = <span style=color:#a6e22e>aws_iam_role</span>.<span style=color:#a6e22e>lambda_name_searcher</span>.<span style=color:#a6e22e>arn</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>resource</span> <span style=color:#e6db74>&#34;aws_lambda_alias&#34;</span> <span style=color:#e6db74>&#34;name_searcher&#34;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>for_each</span> = var.<span style=color:#a6e22e>environments</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>name</span>             = <span style=color:#e6db74>&#34;live&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>description</span>      = <span style=color:#e6db74>&#34;Live version of the lambda. Gradual traffic shifting in place.&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>function_name</span>    = <span style=color:#a6e22e>aws_lambda_function</span>.<span style=color:#a6e22e>name_searcher</span>[each.<span style=color:#a6e22e>key</span>].<span style=color:#a6e22e>arn</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>function_version</span> = <span style=color:#e6db74>&#34;$LATEST&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>lifecycle</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ignore_changes</span> = [<span style=color:#a6e22e>function_version</span>]
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>ignore_changes</code> part here is important because I want CI to manage releases.</p><p>The rest is pretty standard. An S3 bucket, some Terraform config for managing
the Github repository and so on.</p><p>After creating the initial infrastructure I&rsquo;ve decided to create a Go module
to take care of canary Lambda deployments. Therefore, I&rsquo;ve created a module
around AWS SDK and integrated into the CI setup of all my personal lambda
projects.</p><p>Here are you can have a look:</p><figure><a href=https://github.com/msdundar/kanarya><img loading=lazy src=kanarya-sm.png></a><figcaption><p><a href=https://github.com/msdundar/kanarya><a href=https://github.com/msdundar/kanarya>https://github.com/msdundar/kanarya</a></a></p></figcaption></figure><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://learn.hashicorp.com/tutorials/terraform/lambda-api-gateway>https://learn.hashicorp.com/tutorials/terraform/lambda-api-gateway</a></li><li><a href=https://johnroach.io/2020/09/04/deploying-lambda-functions-with-terraform-just-dont/>https://johnroach.io/2020/09/04/deploying-lambda-functions-with-terraform-just-dont/</a></li><li><a href=https://medium.com/galvanize/aws-lambda-deployment-with-terraform-24d36cc86533>https://medium.com/galvanize/aws-lambda-deployment-with-terraform-24d36cc86533</a></li><li><a href=https://docs.aws.amazon.com/sdk-for-go/api/service/lambda/>https://docs.aws.amazon.com/sdk-for-go/api/service/lambda/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.serhatdundar.com/tags/aws/>aws</a></li><li><a href=https://www.serhatdundar.com/tags/lambda/>lambda</a></li><li><a href=https://www.serhatdundar.com/tags/golang/>golang</a></li></ul><nav class=paginav><a class=prev href=https://www.serhatdundar.com/posts/symmetric-and-asymmetric-encryption/><span class=title>« Prev</span><br><span>Symmetric and Asymmetric Encryption</span></a>
<a class=next href=https://www.serhatdundar.com/posts/book-review-the-design-of-web-apis/><span class=title>Next »</span><br><span>Book Review: The Design of Web APIs</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Canary AWS Lambda Deployments on twitter" href="https://twitter.com/intent/tweet/?text=Canary%20AWS%20Lambda%20Deployments&url=https%3a%2f%2fwww.serhatdundar.com%2fposts%2fcanary-aws-lambda-deployments%2f&hashtags=aws%2clambda%2cgolang"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Canary AWS Lambda Deployments on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwww.serhatdundar.com%2fposts%2fcanary-aws-lambda-deployments%2f&title=Canary%20AWS%20Lambda%20Deployments&summary=Canary%20AWS%20Lambda%20Deployments&source=https%3a%2f%2fwww.serhatdundar.com%2fposts%2fcanary-aws-lambda-deployments%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Canary AWS Lambda Deployments on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.serhatdundar.com%2fposts%2fcanary-aws-lambda-deployments%2f&title=Canary%20AWS%20Lambda%20Deployments"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Canary AWS Lambda Deployments on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.serhatdundar.com%2fposts%2fcanary-aws-lambda-deployments%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Canary AWS Lambda Deployments on whatsapp" href="https://api.whatsapp.com/send?text=Canary%20AWS%20Lambda%20Deployments%20-%20https%3a%2f%2fwww.serhatdundar.com%2fposts%2fcanary-aws-lambda-deployments%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Canary AWS Lambda Deployments on telegram" href="https://telegram.me/share/url?text=Canary%20AWS%20Lambda%20Deployments&url=https%3a%2f%2fwww.serhatdundar.com%2fposts%2fcanary-aws-lambda-deployments%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.serhatdundar.com/>Blog of Serhat M. Dündar | Ruby, Rails, Golang, PostgreSQL, AWS, Security</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>